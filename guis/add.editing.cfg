//READING THE HINTS AND DESCRIPTIONS IS USEFULL!! ;)
//NOTE: sub1_mapedit_active "first is the name of the submenu command; the second the name of the button with "_" instead of spaces, its needed to detect which button is active for different colours
// "TODO" marks changeable things and things which arent finished

// init vars
	//menu vars
sub1_mapedit_active = "info Info"
sub1_material_active = "general General"
sub1_geometry_active = "general General"
sub1_RWP_active = "routes Routes"
sub1_editoptions_active = "general General"

	//vars
detectedaction = ""	//for bordertabbuttons
buttonsrollover_count = 0	//for bordertabbuttons

matfilternum = ""	//materialmenu; "": no filter
geofilternum = 0	//materialmenu; 0: no filter

routeidmax = 3 //routes menu
routeidslidmin = 0 //routes menu

pointaliasmax = 6 //point alias menu
pointaliasslidemin = 0 //point alias menu

prefablistindex = 0 //prefab menu
prefabnew = "" //prefab menu

// gui commands
			//short BtB
bordertabbutton = [//$arg1 = name; $arg2 = buttonaction; $arg3 = 0 (horiz), = 1 (vertic), $arg4 = buttonfontsize; $arg5 = which tabmenu for checking if its active or not
	if (=s (stringreplace (sublist $$arg5 1 1) "_" " ") $arg1) [isactive = 1] [isactive = 0]
	if $isactive [//colour for active not active
		BtBtextcolour = "0xFFFFFF"
	][
		BtBtextcolour = "0x808080"
	]
	if (&~ (=s $detectedaction $arg2) $isactive) [//if the button is rollovered; this is connected with the buttonrollover cmd at the end of newgui
		BtBbordercol = "0xFF0000"
	][
		BtBbordercol = "0x555555"
	]
	guilist [ guifont $arg4 [
		guibackground 0x555555 0.7 $BtBbordercol 0.7 1
		if $arg3 [//button horizontal
			guistrut 0.1
			guilist [
				guistrut 0.4
				if $isactive [//when button active guinohitfx
					guinohitfx [
						guibutton $arg1 $arg2 [] [] $BtBtextcolour
					]
				][
					guibutton $arg1 $arg2 [] [] $BtBtextcolour
				]
				guistrut 0.4
			]
			guistrut 0.1
		][//button vertical
			guilist [
				guistrut 0.1
				guilist [
					guistrut 0.4
				if $isactive [//when button active guinohitfx
					guinohitfx [
						guibutton $arg1 $arg2 [] [] $BtBtextcolour
					]
				][
					guibutton $arg1 $arg2 [] [] $BtBtextcolour
				]
					guistrut 0.4
				]
				guistrut 0.1
			]
		]
	] ]
	
]
bordertabbuttonrollover_test = [//test if you onhover over the bordertabbuttons
	if $guirolloveraction [
		detectedaction = $guirolloveraction
		buttonsrollover_count = (+ $guipasses 2)
	][
		if (= $buttonsrollover_count $guipasses)[//deletes only after two no guirolloveractions behind
			detectedaction = ""
			buttonsrollover_count = (+ $guipasses 2)
		]
	]
]
			//guibutton with a guirolloveraction; $arg3 = "#saycommand" indicator for using $arg2 as "saycommand /$arg2"; searches only edit binds; for even number of guilists or use guieditbodun2
guieditbodun = [//$arg1 = name; $arg2 = action; $arg3 = alt-act; $arg4 = icon; $arg5 = colour; $arg6 = onhover
	local cmd // in case there is semicolon to escape
	if $arg3 [//if theres an alt-action
		if (=s $arg3 "#saycommand") [//use saycommand from $arg2
			cmd = (format "saycommand /%1 " (stringreplace $arg2 ";" "^";^""))
		][//use $arg3 as alt-action
			cmd = (stringreplace $arg3 ";" "^";^"")
		]
	][//no alt-action
		cmd = ""
	]
	guibody [
		guibutton $arg1 [] [] $arg4 $arg5
		if (&& (stringlen (dobindsearch [@arg2] edit)) (stringlen $arg2)) [
			guistrut 1
			guibutton (dobindsearch [@arg2] edit)
		]
	] $arg2 $cmd $arg6
]
guieditbodun2 = [ //just guieditbodun with a guilist; for uneven mumber of guilists
	guilist [ guieditbodun $arg1 $arg2 $arg3 $arg4 $arg5 $arg6 ]
]
			//guicheckbox with a guirolloveraction
guibobox = [//$arg1 = name; $arg2 = var; $arg3 = on; $arg4 = onchange; $arg5 = colour; $arg6 = onhover
	guibody [
		guicheckbox $arg1 $arg2 $arg3 $arg4
		if (&& (stringlen [@arg2 (= $@arg2 0); if (= $@arg2 0) [echo @@arg2 OFF] [ echo @@arg2 ON]]) (stringlen $arg2)) [
			guistrut 1
			guibutton (dobindsearch [@arg2 (= $@arg2 0); if (= $@arg2 0) [echo @@arg2 OFF] [ echo @@arg2 ON]] edit)
		]
	] [if (= $@arg2 0) [echo @@arg2 OFF] [echo @@arg2 ON]] [saycommand /@arg2""] $arg6
]
			//for using the inputgui use this schema: (<what to do with the result of inputgui> (inputgui <header message> <which var should be changed> <ok button execute> <guistatus msg>) )
			//WARNING! Ok Button needs in the action even the cleargui 1
inputgui = [//$arg1 = header message; $arg2 = input var; $arg3 = what to do when you want to change it; $arg4 = Cancel Button; $arg4 = special message, e.g. hints; result = when ok the written content
	input_temp_var = $arg2
	inputgui_prev = $$arg2// content of the var/cmd
	inputgui_result = ""
	inputgui_exec = $arg3//content will execute when pressing ok
	input_temp_msg = $arg4
	newgui input_gui [
		guiheader @arg1
		guitext (format "^fwCurrent: ^fC%1" $inputgui_prev) [] [] [] [5000]
		guistrut 0.5
		guicenter [
			guifield inputgui_result -30 [] [0xFFFFFF] [1] [] [] ""
		]
		guistrut 0.5
		guicenter [ guifont "command" [
			guibutton "^fgOK" [
				(inputgui_exec)
			]
			guistrut 3
			guibutton "^frCancel" [cleargui 1]
		] ]
		if $input_temp_msg [
			guifont "little" [
				guistatus $input_temp_msg [5000]
			]
		]
	]
	showgui input_gui
]
			//extended guislider, adds an option for the length
guisliderext = [//$arg1 = sliderlength; $arg2 = var; $arg3 = min; $arg4 = max; $arg5 = onchange; $arg6 = reverse; $arg7 = scroll; $arg8 = colour; $arg9 = style; $arg10 = slidercolour
	guistrut 0.2
	guilist [
		guistrut $arg1 1
		guislider $arg2 $arg3 $arg4 $arg5 $arg6 $arg7 $arg8 $arg9 $arg10
	]
]
			//$$curvar the current value of $curvar
guiresetbut = [ //$arg1 = var
	curvar = $arg1
	if (= (getvartype $curvar) 1) [getvardef_temp = "getfvardef"] [getvardef_temp = "getvardef"]// if its a float or not
	guicenter [ //button for resetting to default
		if (=f $$curvar ($getvardef_temp $curvar)) [ //the var has the default value
			guinohitfx [
				guiimage "textures/checkdisable" [] 0.6
			]
		][ //the var has not the default value
			guiimage "textures/guiexit" [@curvar ($getvardef_temp @curvar)] 0.6
		]
	]
]
			//custom guifontsize
guifontext = [ //$arg1 = fontsize; $arg2 content
	fontalias (format "fontsize %1" $arg1) "default"
	fontscale $arg1
	guifont (format "fontsize %1" $arg1) [
		arg2 //executes the second arg
	]
]

//commands
			//returns a hex value based on a decimal number
dectohex = [//$arg1 = decimal number; result = hex number
	if (=s $arg1 "") [
		result = "0x0"
	]
	curvalue = $arg1
	hex_result = ""
	while [!= $curvalue 0] [
		curhex = (mod $curvalue 16)
		case ($curhex
			) 10 [ curhex = "A"
			] 11 [ curhex = "B"
			] 12 [ curhex = "C"
			] 13 [ curhex = "D"
			] 14 [ curhex = "E"
			] 15 [ curhex = "F"
		]
		hex_result = (concatword $curhex $hex_result)
		curvalue = (div $curvalue 16)
	]
	hex_result = (concatword "0x" $hex_result)
	result $hex_result
]
playersonserv = [
	result (- (listlen (listclients 1 0)) (listlen (listclients 0 2)))
]
			//returns true if the $arg2 is more multiple in the list (only numbers)
ismultipleinlist = [//$arg1 list; $arg2 item
	count_temp = 0
	doubled_tmp = (listfind i $arg1 [ //returns true if one item is more then one time there
			if (= $arg2 $i) [ //if the item is the same as the $arg2
				count_temp = (+ $count_temp 1)
			]
			result (= $count_temp 2) //return true if the item was found two times
			])
	if (!= $doubled_tmp -1) [ //if the item multiple times there
		result 1
	][
		result 0
	]
]

// gui structure
newgui editing_gui [
	guiheader "Map"
		(mapedit_tab)
	guitab "Material"
		(material_tab)
	guitab "Geometry"
		(geometry_tab)
	guitab "RWP"
		(RWP_tab)
	guitab "Options"
		(editoptions_tab)
	bordertabbuttonrollover_test //guirollover for bordertabs to make them red when rollover only ONE time in the gui
]

// gui tabs
mapedit_tab = [
	guistayopen [
		guilist [//submenu row
			guilist [
				guilist [
					bordertabbutton "Info" [sub1_mapedit_active = "info Info"] 1 "command" "sub1_mapedit_active"
					guistrut 0.5
					bordertabbutton "Save and load" [sub1_mapedit_active = "save_and_load Save_and_load"] 1 "command" "sub1_mapedit_active"
					guistrut 0.5
					bordertabbutton "Settings" [sub1_mapedit_active = "settings Settings"] 1 "command" "sub1_mapedit_active"
				]
				guistrut 0.4
			]
			guistrut 0.6
		]
		((format "sub1_mapedit_%1" (sublist $sub1_mapedit_active 0 1)) ) //cexecutes the choosen menu
	]
	guivisibletab [guistatus $guistatus_mapedit_msg [3500]]
]

sub1_mapedit_info = [
	guistatus_mapedit_msg = "Map main menu - info"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	guilist [
		if $maptitle [
			guieditbodun $maptitle [(inputgui "Set mapname" maptitle [maptitle $inputgui_result; cleargui 1])] [saycommand /maptitle""] [] [0xFFFFFF] [guistatus_mapedit_msg = "change the maptitle^n^fB/maptitle"]//inputgui: cmd
		][
			guieditbodun "<name>" [(inputgui "Set mapname" maptitle [maptitle $inputgui_result; cleargui 1])] [saycommand /maptitle""] [] [0xFFFFFF] [guistatus_mapedit_msg = "change the maptitle^n^fB/maptitle"]//inputgui: cmd
		]
		guitext "^fw created by "
		if $mapauthor [
			guieditbodun $mapauthor [(inputgui "Set mapauthor" mapauthor [mapauthor $inputgui_result; cleargui 1])] [saycommand /mapauthor""] [] [0xFFFFFF] [guistatus_mapedit_msg = "change the mapauthor^n^fB/mapauthor"]//inputgui: cmd
		][
			guieditbodun "<name>" [(inputgui "Set mapauthor" mapauthor [mapauthor $inputgui_result; cleargui 1])] [saycommand /mapauthor""] [] [0xFFFFFF] [guistatus_mapedit_msg = "change the mapauthor^n^fB/mapauthor"]//inputgui: cmd
		]
		guispring 1
	]
	guilist [
		guilist [
			guistrut 0.5
			guibody [ guinohitfx [
				guiimage (format "%1.png" $mapname) [] [10] [0] "textures/nothumb"
			] ] [showgui newmapshot] [] [guistatus_mapedit_msg = "click to make a new mapshot^n^fB/savemapshot"]
		]
		guistrut 0.5
		guibar 8 0 0xFFFFFF
		guistrut 0.5
		guilist [
			guistrut 0.3
			guitext (format "^fwCrc: ^fa%1" (dectohex $mapcrc))
			guitext (format "^fwRevision: ^fa%1" (maprevision))
			guitext (format "^fwSize: ^fa%1" (mapsize))
			guitext (format "^fwBounding box size: ^fa%1" (<< 1 $mapsize))
			guilist [
				guitext "^fwFile: "
				guieditbodun $mapname [
					(inputgui "Set mapfile" mapname [//inputgui: cmd
						if $inputgui_result [ //if a mapfile is given
							if (= (stringstr $inputgui_result ".") -1) [ //when no dot is found in the file path
								showhintgui_temp = 0 //no hint menu needed (spaces replacing)
								if (!= (stringstr $inputgui_result " ") -1) [ //if replacing spaces is needed
									showhintgui_temp = 1
									inputgui_result = (stringreplace $inputgui_result " " "_") //prevent spaces in the mapname because then the map cant saved correct
								]
								if (= (stringstr $inputgui_result "/") -1) [ //when no subfolder is found
									(mapname (concatword "maps/" $inputgui_result))
								][ //when a subfolder is found
									(mapname $inputgui_result)
								]
								if $showhintgui_temp [ //show a hint when spaces has been replaced
									newgui info [guiheader "info"; guione [ guitext [Spaces has been replaced with "_"] ] ]; showgui info //if nothing has changed
									sleep 2000 [cleargui 2]
								]
							][ //when a dot is found in the file path; you can get in trouble when using dots
								newgui info [guiheader "info"; guione [ guitext "A dot in the mapfile is not recommend ^frNothing^fw changed..." ] ]; showgui info //if nothing has changed
								sleep 4000 [cleargui 2]
							]
						][ //when no mapfile is given
							newgui info [guiheader "info"; guione [ guitext "No mapfile given. ^frNothing^fw changed..." ] ]; showgui info //if nothing has changed
							sleep 2000 [cleargui 2]
						]
					] "The map will be saved in the user directory. For sub folder use this schema: folder/folder/.../mapfilename^nIf no folder is given it will be saved under maps/")
					showgui input_gui
				] [saycommand /mapname""] [] [0xFFFFFF] [guistatus_mapedit_msg = "change the mapname^n^fB/mapname"]
			]
			guitext (format "^fwFile format version: ^fa%1" (mapversion))
			guilist [
				guitext "^fwMapmusic: "
				if $mapmusic [
					guieditbodun $mapmusic [showgui chosemusic] [saycommand /mapmusic""] [] [0xFFFFFF] [guistatus_mapedit_msg = "change mapmusic^n^fB/mapmusic"]
				][
					guieditbodun "<Music>" [showgui chosemusic] [saycommand /mapmusic""] [] [0xFFFFFF] [guistatus_mapedit_msg = "chose a mapmusic^n^fB/mapmusic"]
				]
			]
			guibutton "^fredit the config file" [notepad @mapname.cfg] []
		]
	]
]
sub1_mapedit_save_and_load = [
	guistatus_mapedit_msg = "Save and load"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	if (isonline) [ guieditbodun "Refresh map from server" [getmap] [#saycommand] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Loads the current server version of the map^n^fB/%1" $arg2)] ]
	guieditbodun "Save map" [savemap] [#saycommand] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Saves the map ^n^fB/%1" $arg2)]
	guieditbodun "Save waypoints" [savewaypoints] [#saycommand] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Saves only the waypoints^n^fB/%1" $arg2)]
	guieditbodun "Save map with waypoints" [savemap; savewaypoints] [#saycommand] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Saves the map with waypoints^n^fB/%1" $arg2)]
	guieditbodun "Save map as final version" [shrinkmap; texturecull; fullbright 0; calclight 1; savemap; savewaypoints] [#saycommand] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Calc light and clear all unused textures from map cfg and saves the map^n^fB/%1" $arg2)]
	guistrut 0.5
	if (isonline) [ //when online show vote instead of reload
		guieditbodun "Vote map again" [savewarnchk [edit $mapname]] [saycommand /edit @mapname] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Vote or force editing the current map^n^fB/%1" $arg2)]
	][
		guieditbodun "Reload map" [savewarnchk [edit $mapname] ] [saycommand /edit @mapname] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Reload the current map^n^fB/%1" $arg2)]
	]
	if (findfile (format "%1.wpt" $mapname)) [
			guieditbodun "Reload waypoints" [loadwaypoints] [#saycommand] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Reload the waypoints for this map^n^fB/%1" $arg2)]
	]
	guieditbodun "Load a previous version" [showgui prev_mapversion] [] [] [0xFFFFFF] [guistatus_mapedit_msg = "Choose and load a previous version of this mapname"]
	guistrut 1
	autosaveinterval
]
sub1_mapedit_settings = [
	guistatus_mapedit_msg = "Map settings"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	guilist [
		guilist [ //first column
			guistrut 0.1; guieditbodun "Numplayers:" [] [saycommand /numplayers""] [] [0xFFFFFF] [guistatus_mapedit_msg = "numplayers (0-256)^n^fB/numplayers"]
			guistrut 0.25; guieditbodun "Maxplayers:" [] [saycommand /maxplayers""] [] [0xFFFFFF] [guistatus_mapedit_msg = "Maximum players who can play on this map (0-256)^n^fB/maxplayers"]
			guistrut 0.25; guieditbodun "Asymetric Map:" [] [saycommand /mapbalance""] [] [0xFFFFFF] [guistatus_mapedit_msg = "Switch the teams after halftime^n^fo0 ^fw= No balance; ^fo1 ^fw= Oly balance in ctf/dac/bb; ^fo2 ^fw= balance in all modes; ^fo3 ^fw= forced^n^fB/mapbalance"]
		]
		guistrut 1
		guilist [ //second column
			guibody [
				guifield numplayers 3 [] [0xFFFFFF] [] [] [] ""
				guistrut 1
				guiresetbut "numplayers"
				guistrut 1
				guicenter [ guilist [
					guisliderext 15 numplayers 0 256 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /numplayers""] [guistatus_mapedit_msg = "numplayers (0-256)^n^fB/numplayers"]
			guibody [
				guifield maxplayers 3 [] [0xFFFFFF] [] [] [] ""
				guistrut 1
				guiresetbut "maxplayers"
				guistrut 1
				guicenter [ guilist [
					guisliderext 15 maxplayers 0 256 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /maxplayers""] [guistatus_mapedit_msg = "Maximum players who can play on this map (0-256)^n^fB/maxplayers"]
			guibody [
				guifield mapbalance 3 [] [0xFFFFFF] [] [] [] ""
				guistrut 1
				guiresetbut "mapbalance"
				guistrut 1
				guicenter [ guilist [
					guisliderext 15 mapbalance 0 3 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /mapbalance""] [guistatus_mapedit_msg = "Switch the teams after halftime^n^fo0 ^fw= No balance; ^fo1 ^fw= Only balance in ctf/dac/bb; ^fo2 ^fw= balance in all modes; ^fo3 ^fw= forced^n^fB/mapbalance"]
		]
	]
	guistrut 1
	guieditbodun "Increase map size" [mapenlarge] [#saycommand] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Increases the mapsize^n^fB/%1" $arg2)]
	guieditbodun "Cull empty space" [shrinkmap] [#saycommand] [] [0xFFFFFF] [guistatus_mapedit_msg = (format "Shrinks the map size to smallest cubed area, only empty space outside of the map will be removed^n^fB/%1" $arg2)]
]
//~~~~~~~~~~~~~~~~~~
material_tab = [
	guistayopen [
		guilist [//submenu row
			guilist [
				guilist [
					bordertabbutton "General" [sub1_material_active = "general General"] 1 "command" "sub1_material_active"
					guistrut 0.5
					bordertabbutton "Water" [sub1_material_active = "water Water"] 1 "command" "sub1_material_active"
					guistrut 0.5
					bordertabbutton "Grass" [sub1_material_active = "grass Grass"] 1 "command" "sub1_material_active"
					guistrut 0.5
					bordertabbutton "Obituaries" [sub1_material_active = "obituaries Obituaries"] 1 "command" "sub1_material_active"
					guistrut 0.5
					bordertabbutton "Filter" [sub1_material_active = "filter Filter"] 1 "command" "sub1_material_active"
					guistrut 0.5
				]
				guistrut 0.4
			]
			guistrut 0.6
		]
		((format "sub1_material_%1" (sublist $sub1_material_active 0 1)) ) //cexecutes the choosen menu
	]
	guivisibletab [guistatus $guistatus_material_msg [3500]]
]

sub1_material_general = [
	guistatus_material_msg = (format "material options - for a short menu press %1" (dobindsearch "showgui materials" edit))
	guibar 10 0 0xFFFFFF
	guistrut 0.5
	guibody [
		guicheckbox "show material volumes" showmat
		guistrut 0.5
		guibutton (dobindsearch "showmat (= $showmat 0); if (= $showmat 0) [echo showmat OFF] [ echo showmat ON]" edit)
	] [if $showmat [showmat 1; echo "showmat ON"] [showmat 0; echo "showmat OFF"]] [saycommand /@showmat] [guistatus_materialmenu_msg = "show material volumes^n^fB/showmat"]
	guistrut 0.4
	guilist [ //heading line
		guitext "material" [] [0x30ACAC]
		guistrut 5
		guitext "colours" [] [0x30ACAC]
		guistrut 7.7
		guitext "fog" [] [0x30ACAC]
		guistrut 6.8
		guitext "spec" [] [0x30ACAC]
	]
	guistrut 0.2
	s = 1
	looplist i [water lava glass] [ //lists the water, lava, glass options
		looplist j ["" 2 3 4] [ //adds the numbered materials
			guilist [
				guitext (tabify @i@j 2)
				guilist [
					guibackground $@i@(j)colour $guibgblend [] [] 0 //makes the background coloured as the current colour because the button needs to be visible even when its black
					guilist [
						guistrut 0.3
							guilist [
								guistrut 0.05
								guieditbodun "colour" [ice_pickcolour @@i@@(j)colour] [saycommand /@@i@@(j)colour""] [] [0xFFFFFF] [guistatus_material_msg = (format "colour of %1^n^fB/%1colour" @@i@@(j))] //opens the pickcolour menu
								guistrut 0.05
							]
						guistrut 0.3
					]
				]
				guistrut 1
				if (=s $i "water") [ //only water has a fallcolour
					guilist [
						guibackground $@i@(j)colour $guibgblend [] [] 0 //makes the background coloured as the current colour because the button needs to be visible even when its black
						guilist [
							guistrut 0.3
								guilist [
									guistrut 0.05
									guieditbodun "fallcolour" [ice_pickcolour @@i@@(j)fallcolour] [saycommand /@@i@@(j)fallcolour""] [] [0xFFFFFF] [guistatus_material_msg = (format "waterfall colour of %1^n^fB/%1fallcolour" @@i@@(j))] //opens the pickcolour menu
									guistrut 0.05
								]
							guistrut 0.3
						]
					]
					guistrut 1
				] [guistrut 9.05]
				if (!=s $i "glass") [
					guibody [guifield @i@(j)fog 4] [] [] [guistatus_material_msg = (format "fog distance inside %1^n^fB/%1fog" @i@(j))]
					guistrut 0.5
					guiresetbut @i@(j)fog
				]
				guistrut 0.75
				if (s) [
					guibody [guifield @i@(j)spec 4] [] [] [guistatus_material_msg = (format "specularity %1^n^fB/%1spec" @i@(j))]
					guistrut 0.5
					guiresetbut @i@(j)spec
				]
			]
			if (=s $i "glass") [guistrut 0.3]
		]
		s = 0
	]
]
sub1_material_water = [
	guistatus_material_msg = "Water options"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	guilist [
		guilist [ //first column
			guistrut 0.1; guieditbodun "Watersubdiv:" [] [saycommand /watersubdiv""] [] [0xFFFFFF] [guistatus_material_msg = "water subdiv (0-3)^n^fB/watersubdiv"]
			guistrut 0.25; guieditbodun "Waterlod:" [] [saycommand /waterlod""] [] [0xFFFFFF] [guistatus_material_msg = "water resoltion (0-3)^n^fB/waterlod"]
			guistrut 0.25; guieditbodun "Causticscale:" [] [saycommand /causticscale""] [] [0xFFFFFF] [guistatus_material_msg = "water caustic size (0-10000)^n^fB/causticscale"]
			guistrut 0.25; guieditbodun "Causticmillis:" [] [saycommand /causticmillis""] [] [0xFFFFFF] [guistatus_material_msg = "water caustic speed (0-1000)^n^fB/causticmillis"]
		]
		guistrut 2
		guilist [ //second column
			guibody [
				guifield watersubdiv 1 [] [0xFFFFFF] [] [] [] ""
				guistrut 5
				guiresetbut "watersubdiv"
				guistrut 1
				guicenter [ guilist [
					guisliderext 8 watersubdiv 0 3 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /watersubdiv""] [guistatus_material_msg = "water subdiv (0-3)^n^fB/watersubdiv"]
			guibody [
				guifield waterlod 1 [] [0xFFFFFF] [] [] [] ""
				guistrut 5
				guiresetbut "waterlod"
				guistrut 1
				guicenter [ guilist [
					guisliderext 8 waterlod 0 3 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /waterlod""] [guistatus_material_msg = "water resoltion (0-3)^n^fB/waterlod"]
			guibody [
				guifield causticscale 5 [] [0xFFFFFF] [] [] [] ""
				guistrut 1
				guiresetbut "causticscale"
				guistrut 1
				guicenter [ guilist [
					guisliderext 25 causticscale 1 10000 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /causticscale""] [guistatus_material_msg = "water caustic size (0-10000)^n^fB/causticscale"]
			guibody [
				guifield causticmillis 4 [] [0xFFFFFF] [] [] [] ""
				guistrut 2
				guiresetbut "causticmillis"
				guistrut 1
				guicenter [ guilist [
					guisliderext 25 causticmillis 1 1000 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /causticmillis""] [guistatus_material_msg = "water caustic speed (0-1000)^n^fB/causticmillis"]
		]
	]
]
sub1_material_grass = [
	guistatus_material_msg = "Grass options"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	guilist [
		guilist [
			guistrut 0.1; guieditbodun "Grassblend:" [] [saycommand /grassblend""] [] [0xFFFFFF] [guistatus_material_msg = "grass blending (0.0-1.0^n^fB/grassblend"]
			guistrut 0.25; guieditbodun "Grassscale:" [] [saycommand /grassscale""] [] [0xFFFFFF] [guistatus_material_msg = "all grass textures scaling (0-64)^n^fB/grassscale"]
			guistrut 0.25; guieditbodun "Grassheight:" [] [saycommand /grassheight""] [] [0xFFFFFF] [guistatus_material_msg = "grass height (0-64)^n^fB/grassheight"]
			guistrut 0.25; guieditbodun "Grassanimmillis:" [] [saycommand /grassanimmillis""] [] [0xFFFFFF] [guistatus_material_msg = "grass animation speed (0-60000)^n^fB/grassanimmillis"]
			guistrut 0.25; guieditbodun "Grassanimscale:" [] [saycommand /grassanimscale""] [] [0xFFFFFF] [guistatus_material_msg = "grass animation scale (0.0-1.0)^n^fB/grassanimscale"]

		]
		guistrut 1
		guilist [
			guibody [
				guifield grassblend 4 [] [0xFFFFFF] [] [] [] ""
				guistrut 2
				guiresetbut "grassblend"
				guistrut 1
				grassblendstorage = (*f $grassblend 100)
				guicenter [ guilist [
					guisliderext 25 grassblendstorage 1 100 [grassblend (divf $grassblendstorage 100) ] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /grassblend""] [guistatus_material_msg = "grass blending (0.0-1.0^n^fB/grassblend"]
			guibody [
				guifield grassscale 2 [] [0xFFFFFF] [] [] [] ""
				guistrut 4
				guiresetbut "grassscale"
				guistrut 1
				guicenter [ guilist [
					guisliderext 25 grassscale 1 64 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /grassscale""] [guistatus_material_msg = "all grass textures scaling (0-64)^n^fB/grassscale"]
			guibody [
				guifield grassheight 2 [] [0xFFFFFF] [] [] [] ""
				guistrut 4
				guiresetbut "grassheight"
				guistrut 1
				guicenter [ guilist [
					guisliderext 25 grassheight 1 64 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /grassheight""] [guistatus_material_msg = "grass height (0-64)^n^fB/grassheight"]
			guibody [
				guifield grassanimmillis 5 [] [0xFFFFFF] [] [] [] ""
				guistrut 1
				guiresetbut "grassanimmillis"
				guistrut 1
				guicenter [ guilist [
					guisliderext 25 grassanimmillis 0 60000 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /grassanimmillis""] [guistatus_material_msg = "grass animation speed (0-60000)^n^fB/grassanimmillis"]
			guibody [
				guifield grassanimscale 4 [] [0xFFFFFF] [] [] [] ""
				guistrut 2
				guiresetbut "grassanimscale"
				guistrut 1
				grassanimscalestorage = (*f $grassanimscale 100)
				guicenter [ guilist [
					guisliderext 25 grassanimscalestorage 1 100 [grassanimscale (divf $grassanimscalestorage 100) ] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [saycommand /grassanimscale""] [guistatus_material_msg = "grass animation scale (0.0-1.0)^n^fB/grassanimscale"]
		]
	]
	guistrut 0.3
	guilist [
		guibackground $grasscolour $guibgblend [] [] 0 //makes the background coloured as the current colour because the button needs to be visible even when its black
		guistrut 0.3
		guilist [
			guistrut 0.05
			guieditbodun "grasscolour" [ice_pickcolour grasscolour] [saycommand /grasscolour""] [] [0xFFFFFF] [guistatus_material_msg = "Set the colour of grass^n^fB/grasscolour"]
			guistrut 0.05
		]
		guistrut 0.3
	]
	guistrut 1
	guibody [ guitext "grass" [] [0x30ACAC] ] [] [] [guistatus_material_msg = "use choosen gras on the current selected texture"]
	guilistsplit i 3 [
		textures/grass
		nobiax/grass01
		nobiax/grass02
		nobiax/grass03
		nobiax/grassbush
		luckystrike/grass_lucky
		luckystrike/grass_lucky_alt
		luckystrike/grass_lucky_bright
		luckystrike/grass_lucky_green
	] [
		//guiimage $i ... non-square images are not aligned correctly atm
		guifont huge [ guieditbodun (format "^f(%1)" $i) [setgrass @i] [#saycommand] [] [0xFFFFFF] [guistatus_material_msg = "use choosen gras on the selected texture"] ]
		guistrut 0.2
	]
	guieditbodun "^fyclear^fa from texture" [setgrass ""] [#saycommand] [] [0xFFFFFF] [guistatus_material_msg = "delete the used grass from the selected texture"]
]
sub1_material_obituaries = [
	guistatus_material_msg = "modify the messages for dying in specific material or falling down"
	guibar 10 0 0xFFFFFF
	guistrut 0.5
	guilist [ //heading line
		guitext "material" [] [0x30ACAC]
		guistrut 9
		guitext "message" [] [0x30ACAC]
	]
	guistrut 0.2
	guilist [
		guilist [
			looplist i [fall death water water2 water3 water4 lava lava2 lava3 lava4] [ //makes a list of all obituaries, when nothing is given it shows the default
				guistrut 0.25
				guibody [guibutton $i] [] [saycommand /obit@i""] [guistatus_material_msg = (format "death message for dying in %1^n^fB/obit%1" @i)]
			]
		]
		guistrut 1
		guilist [
			looplist i [fall death water water2 water3 water4 lava lava2 lava3 lava4] [ //makes a list of all obituaries, when nothing is given it shows the default
				guilist [
					cases @i "fall" [
						curobitmsg = "obitlost"
						] "death" [
						curobitmsg = "obitdeathmat"
					]
					if (=s (substring @i 0 4) "lava") [
						curobitmsg = "obitmelted"
					][ //if (=s (substring @i 0 5) "water")
						curobitmsg = "obitdrowned"
					]
					guibody [ guilist [
						guifield obit@i -22 [] [0xFFFFFF] [] [] [] $$curobitmsg
					] ] [] [] [guistatus_material_msg = (format "death message for dying in %1^n^fB/obit%1" @i)]
					guistrut 1
					guiresetbut $curobitmsg
				]
			]
		]
	]
]
sub1_material_filter = [
	guistatus_material_msg = "Limits the area of the changes ^f[0xFF9999]only for^fw material or geometry (or combinations with them) which is set in the filters"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	guilist [
		guilist [
			if (&& (<= $matfilternum 0) (>= $matfilternum 19)) [ //test if the matfilternum is one of the available filters
				matfilternum = 0
			]
			guicenter [ guitext "Material filter" [] [0x30ACAC] ]
			matfiltername_temp = (? (= $matfilternum 0) (result "filter off") (result (sublist "air alpha water lava clip noclip aiclip death ladder glass water2 water3 water4 lava2 lava3 lava4 glass2 glass3 glass4" (- $matfilternum 1) 1)) )
			guicenter [ guitext (format "(%1)" $matfiltername_temp)]
			guistrut 0.5
			//material filter list, beginning with 0 until 19 is: "no_filter(0) air(1) alpha(2) water(3) lava(4) clip(5) noclip(6) aiclip(7) death(8) ladder(9) glass(10) water2(11) water3(12) water4(13) lava2(14) lava3(15) lava4(16) glass2(17) glass3(18) glass4(19)"
			guibody [ guiradio "filter off" matfilternum 0 [] [0xEEBBBB] ] [] [] [guistatus_material_msg = "material ^fofilter off"] //guiradio "filter off"
			guilist [
				guilist [ //standard material filter
					loop i 10 [//material list; creating the matfilternum from 1 to 10
						guibody [
							name_temp = (sublist "air alpha water lava clip noclip aiclip death ladder glass" $i 1)
							guiradio $name_temp matfilternum (+ $i 1) [] //(+ $i 1) because of excluding "filter off(0)"
						] [] [] [guistatus_material_msg = (format "limit changes to ^fo%1 ^fwmaterial" $name_temp)]
					]
				]
				guistrut 2
				guilist [ //extended material list
					loop i 9 [//material list; creating the matfilternum from 11 to 19
						guibody [
							name_temp = (sublist "water2 water3 water4 lava2 lava3 lava4 glass2 glass3 glass4" $i 1)
							guiradio $name_temp matfilternum (+ $i 11) [] [0xCCCCCC] //(+ $i 1) because of excluding matfilters 1-10
						] [] [] [guistatus_material_msg = (format "limit changes to ^fo%1 ^fwmaterial" $name_temp)]
					]
				]
			]
		]
		guistrut 0.5
		guibar 8 0 0xFFFFFF
		guistrut 0.5
		guilist [
			if (&& (>= $geofilternum 0) (< $geofilternum 6)) [] [geofilternum = 0] ///test if the geofilternum is one of the available filters
			guicenter [ guitext "Geometry filter" [] [0x30ACAC] ]
			guicenter [ guitext (format "(%1)" (stringreplace (sublist "filter_off non-empty empty not_entirely_solid entirely_solid" $geofilternum 1) "_" " ")) ]
			guistrut 0.5
			guibody [ guiradio "filter off" geofilternum 0 [] [0xEEBBBB] ] [] [] [guistatus_material_msg = "geometry^fo filter off"] //guiradio "filter off"
			loop i 4 [//possibilities for the geometry filter; {0 = normal (filter off), 1 = non-empty, 2 = empty, 3 = not entirely solid, 4 = entirely solid}
				name_temp = (stringreplace (sublist "non-empty empty not_entirely_solid entirely_solid" $i 1) "_" " ")
				guibody [
					guiradio $name_temp geofilternum (+ $i 1) //because of excluding "filter off"
				] [] [] [guistatus_material_msg = (format "limit changes to %1 geometry" $name_temp)]
			]
		]
	]
	guistrut 1
	guistayopen [ guibutton "Material menu" [cleargui; showgui materialmenu 1] ]
]
//~~~~~~~~~~~~~~~~~~
geometry_tab = [
	guistayopen [
		guilist [//submenu row
			guilist [
				guilist [
					bordertabbutton "General" [sub1_geometry_active = "general General"] 1 "command" "sub1_geometry_active"
					guistrut 0.5
					bordertabbutton "Prefab" [sub1_geometry_active = "prefab Prefab"] 1 "command" "sub1_geometry_active"
					guistrut 0.5
				]
				guistrut 0.4
			]
			guistrut 0.6
		]
		((format "sub1_geometry_%1" (sublist $sub1_geometry_active 0 1)) ) //cexecutes the choosen menu
	]
	guivisibletab [guistatus $guistatus_geometry_msg [3500]]
]

sub1_geometry_general = [
	guistatus_geometry_msg = "Geometry options"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	guieditbodun "Undo" [undo; passthroughsel 0] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guieditbodun "Redo" [redo] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "redo the last change^n^fB/%1" $arg2)]
	guistrut 0.5
	guieditbodun "Pull cube" [universaldelta -1] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guieditbodun "Push cube" [universaldelta 1] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guieditbodun "Push / pull faces " [domodifier 2] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guieditbodun "Push / pull corners" [domodifier 3] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guistrut 0.5
	guieditbodun "Deselect" [cancelsel] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guistrut 0.5
	guieditbodun "Delete selection (ents first)" [editdel] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guieditbodun "Copy" [editcopy] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guieditbodun "Paste" [editpaste] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guibody [
		guitext "Cut and paste on release" [] [0x303030]
		guistrut 1
		guibutton (dobindsearch "editcut" edit)
	] [] [] [guistatus_geometry_msg = "undo the last change^n^fB/editcut"]
	guistrut 0.5
	guieditbodun "Flip" [editflip] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guibody [
		guitext "Rotate via mouse wheel" [] [0x303030]
		guistrut 1
		guibutton (dobindsearch "domodifier 9" edit)
	] [] [] [guistatus_geometry_msg = "undo the last change^n^fB/domodifier 9"]
	guistrut 0.5
	guieditbodun "Toggle heightmap mode" [hmapedit (! $hmapedit); blendpaintmode 0] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "undo the last change^n^fB/%1" $arg2)]
	guibody [
		guitext "Cycle heightmap brushes via mouse wheel" [] [0x303030]
		guistrut 1
		guibutton (dobindsearch "domodifier 4" edit)
	] [] [] [guistatus_geometry_msg = "undo the last change^n^fB/domodifier 4"]
	guistrut 0.5
	guibody [
		guitext "Change grid size via mouse wheel" [] [0x303030]
		guistrut 1
		guibutton (dobindsearch "domodifier 1" edit)
	] [] [] [guistatus_geometry_msg = "show material volumes^n^fB/domodifier 1"]
	guilist [
		guistrut 2
		guitext "current: " [] [0x707070]
		guitext (<< 1 $gridpower) [] [0x707070]
	]
]
sub1_geometry_prefab = [
	guistatus_geometry_msg = "Prefab options - the prefabs are stored in userconfig/prefab"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	prefabs_list = ""
	slider_prefab = 0
	loopfiles i "prefab" "obr" [append prefabs_list $i]
	guilist [
		guilist [
			guilist [
				guilist [
					guistrut 0.1
					guieditbodun "save prefab" [
						//action
						if (=s @prefabnew "") [
							newgui info [guiheader "info"; guione [ guitext "please give a name first" ; guistrut 1; guicenter [ guibutton "^fgOK" [cleargui 1]] ] ] ; showgui info //if nothing has changed
						][ //if name isnt empty
							if (!= (listfind i $prefabs_list [=s $i $prefabnew]) -1) [//if the current prefabname already exists
								newgui info [
									guiheader "info"
									guicenter [
										guilist [
											guitext (format "prefab^fo %1^fw already exists" $prefabnew)
											guitext "do you want to^fr override^fw this?"
										]
									]
									guicenter [
										guinohitfx [guiprefabpreview $prefabnew -1 [] 7.5 0 []]
									]
									guicenter [ guifont "command" [
										guibutton "^fgOK" [
											saveprefab @prefabnew
											cleargui 1
										]
										guistrut 3
										guibutton "^frCancel" [cleargui 1]
									] ]
								]
								showgui info
							][ //if prefabname isnt exist
								saveprefab @prefabnew
							]
						]
					] [] [] [0xFFFFFF] [guistatus_geometry_msg = (format "saves the selected geometry as an prefab^n^fB/saveprefab")]
				]
				guistrut 1
				guifield prefabnew 10 [] [0xFFFFFF] [] [] [] "^fA<name>" 1
			]
			guistrut 1
			if $prefabs_list [
				guilist [
					guilist [ guilist [
						if (> (listlen $prefabs_list) 10) [ //when guislider is active with more then 10 prefabs
							guislider prefablistindex 0 (- (listlen $prefabs_list) 10) [] 1
							guistrut 0.3
						]
						guilist [
							loop i (min (listlen $prefabs_list) 10) [ //max 10 prefabs are viewable (guislider), using the + because of shifting of the slider
								guiradio (at $prefabs_list (+ $i $prefablistindex)) choprefab (+ $i $prefablistindex) //choprefab is the choosen prefab; + because of the guislider shift
							]
						]
					]]
				]
			][
				guicenter [guitext "^frno^fw prefabs found"]
			]
		]
		guispring 1
		guinohitfx [guiprefabpreview (at $prefabs_list (getalias choprefab)) -1 [] 7.5 1 []]
	]
	guistrut 0.5
	guieditbodun "paste" [pasteprefab (at $prefabs_list (getalias choprefab))] [] [] [0xFFFFFF] [guistatus_geometry_msg = "paste the choosen prefab immediately^n^fB/pasteprefab"]
	guistrut 1.5
	guitext (format "prefabs are scaled by the current grid size: %1" (<< 1 $gridpower))
	guislider gridpower 0 (min (- $mapsize 1) 12)
]
//~~~~~~~~~~~~~~~~~~
RWP_tab = [
	guistayopen [
		guilist [//submenu row
			guilist [
				guilist [
					bordertabbutton "Routes" [sub1_RWP_active = "routes Routes"] 1 "command" "sub1_RWP_active"
					guistrut 0.5
					bordertabbutton "Waypoints" [sub1_RWP_active = "waypoints Waypoints"] 1 "command" "sub1_RWP_active"
					guistrut 0.5
					bordertabbutton "Point aliases" [sub1_RWP_active = "pointaliases Point_aliases"] 1 "command" "sub1_RWP_active"
					guistrut 0.5
				]
				guistrut 0.4
			]
			guistrut 0.6
		]
		((format "sub1_RWP_%1" (sublist $sub1_RWP_active 0 1)) ) //cexecutes the choosen menu
	]
	guivisibletab [guistatus $guistatus_RWP_msg [3500]]
]

sub1_RWP_routes = [
	guistatus_RWP_msg = "routes shows the player (mostly in race) a easy or fast way, but only the route which is selected from every player himself"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	routeid_list = ""
	loop i (getentity -1) [ //saves the id (not entid) in a list from routeid
		if (= (getentity $i 0) 16) [
			currouteid_tmp = (getentity $i 1 0)
			if (= (listfind k $routeid_list [= $k $currouteid_tmp]) -1) [ //add routeid to routeidlist if the id isnt already there
				routeid_list = (concat $routeid_list $currouteid_tmp)
			]
		]
	]
	if (>= $routeid 0) [
		guibobox "drop route ents as you move" droproute [] [] [0xFFFFFF] [guistatus_RWP_msg = (? $droproute "drop no routes" (format "drope routes with id: ^fo%1^n^fB/droproute %2" $routeid (! $droproute)) )]
	][
		guibody [ guitext "^fadrop route ents as you move" [textures/checkdisable.png] ] [] [] [guistatus_RWP_msg = "Select a route id first"]
	]
	guistrut 0.5
	guilist [
		if (> $routeidmax 9) [ //when guislider is active with more then 9 routes
			guistrut 3.5
		]
		guitext "Routes" [] [0x30ACAC]
	]
	guistrut 0.2
	guilist [
		if (> $routeidmax 9) [ //when guislider is active with more then 9 routes
			guistrut 3.3
		]
		guibody [ guiradio "disabled" routeid -1 ] [droproute 0; routeid -1] [] [guistatus_RWP_msg = "disable and hide all routes"]
		guistrut 3.4
		guieditbodun2 "deselect all" [entcancel] [] [] [0xFFFFFF] [guistatus_RWP_msg = (format "deselect all ents^n^fB/%1" $arg2)]
	]
	guilist [
		if (> $routeidmax 9) [ //when guislider is active with more then 9 routes
			guislider routeidslidmin 0 (- $routeidmax 9) [] 1
			guistrut 0.3
		]
		guilist [
			loop i (min $routeidmax 9) [ //when guislider is active with more then 9 routes then it shows only 9 routes
				guilist [
					routeidexists = (!= (listfind k $routeid_list [= $k $i]) -1) //if the routeid exists
					idtemp = (+ $i $routeidslidmin) //adds the beginning of the list when routeidmax is over 9, due to guislider
					guibody [ guiradio (format "id %1" $idtemp) routeid $idtemp ] [] [] [guistatus_RWP_msg = (format "enable and show route ^fo%1^n^fB/routeid %1" $idtemp)]
					guistrut 7
					guispring 1
					if $routeidexists [ //if the id exists
						guieditbodun "select" [entcancel; entfind route @idtemp] [] [] [0xFFFFFF] [guistatus_RWP_msg = (format "select all ents of route ^fo%1^n^fB/%2" $idtemp $arg2)]
					][
						guibody [ guitext "select" [] [0x303030] ] [] [] [guistatus_RWP_msg = (format "the route ^fo%1^fw doesnt exist" $idtemp $arg2)]
					]
				]
			]
		]
	]
	guistrut 0.5
	guilist [
		guieditbodun "more" [routeidmax = (+ $routeidmax 1)] [] [] [0xFFFFFF] [guistatus_RWP_msg = "show more routeids"]
		guistrut 2
		guifield routeidmax 3
		guistrut 2
		guieditbodun "less" [ if (> $routeidmax 1) [ routeidmax = (- $routeidmax 1)] ] [] [] [0xFFFFFF] [guistatus_RWP_msg = "show less routeids"]
	]
	guistrut 0.5
	guieditbodun "echo existing routes" [echo (format "existing routes:^fo%1" (? (=s $routeid_list "") (result " none") (result $routeid_list)) )] [] [] [0xFFFFFF] [guistatus_RWP_msg = "echos all existing route ids"]
	guistrut 0.7
	guitext (format "^faselected entities: %1" (enthavesel))
]
sub1_RWP_waypoints = [
	guistatus_RWP_msg = "waypoints are for usefull for bots that they know where ways are^nwatch out that you dont do slidejumps while creating waypoints, bots cant follow them"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	guicheckbox "show waypoints" showwaypoints
	guicheckbox "drop waypoints as you move" dropwaypoints
	guistrut 0.5
	guieditbodun "clear all waypoints" clearwaypoints [#saycommand] [] [0xFFFFFF] [guistatus_RWP_msg = "delete all waypoints of the map"]
	guieditbodun "clear waypoints in selected volume" delselwaypoints [#saycommand] [] [0xFFFFFF] [guistatus_RWP_msg = "delete only the waypoints in the selected volume"]
	guistrut 0.5
	guilist [ //gamespeed control row
		guilist [ //first column
				guistrut 0.1; guieditbodun "gamespeed:" [] [saycommand /gamespeed""] [] [0xFFFFFF] [guistatus_material_msg = "water subdiv (0-3)^n^fB/watersubdiv"]
		]
		guistrut 2
		guilist [ //second column
			guibody [
				guifield gamespeed 5 [] [0xFFFFFF] [] [] [] ""
				guistrut 1
				guiresetbut "gamespeed"
				guistrut 1
				guicenter [ guilist [
					guisliderext 20 gamespeed 1 1000 [] [] [1] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
			] [] [] [guistatus_material_msg = "water subdiv (0-3)^n^fB/gamespeed"]
		]
	]
	guieditbodun "add bot" addbot [#saycommand] [] [0xFFFFFF] [guistatus_material_msg = "adds a bot who will walk on the waypoints"]
	guieditbodun "remove bot" delbot [#saycommand] [] [0xFFFFFF] [guistatus_material_msg = "remove a bot who will walk on the waypoints"]
	guistrut 0.5
	if (findfile (format "%1.wpt" $mapname)) [
		guieditbodun "reload waypoints" [loadwaypoints] [#saycommand] [] [0xFFFFFF] [guistatus_RWP_msg = "reloads waypoints from the waypoints file"]
		guieditbodun "save waypoints" [savewaypoints] [#saycommand] [] [0xFFFFFF] [guistatus_RWP_msg = "save and overwrite waypoints file"]

	] [
		guieditbodun "save waypoints" [savewaypoints]
	]
]
sub1_RWP_pointaliases = [
	guistatus_RWP_msg = "give points/flags aliases and identify them with ids"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	affinityid_list = ""
	affinityonceid_list = ""
	loop i (getentity -1) [ //saves the id (not entid) in a list from affinities
		if (= (getentity $i 0) 14) [ affinityid_list = (concat $affinityid_list (getentity $i 1 5)) ]
	]
	affinityid_list = (sortlist $affinityid_list a b [< $a $b]) //sorted id list
	looplist i $affinityid_list [ //returns $affinityonceid_list list with no doubled ids
		if (= (listfind k $affinityonceid_list [= $k $i]) -1) [ //if current id is not already in the once item list
			affinityonceid_list = (concat $affinityonceid_list $i)
		]
	]

	guilist [
		if (> $pointaliasmax 10) [ //when guislider is active with more then 10 point aliases
			guistrut 3.3
		]
		guitext "point" [] [0x30ACAC]
		guistrut 11.5
		guitext "point alias" [] [0x30ACAC]
	]
	guistrut 0.2
	guilist [
		if (> $pointaliasmax 10) [ //when guislider is active with more then 10 point aliases
			guislider pointaliasslidemin 0 (- $pointaliasmax 10) [] 1
			guistrut 0.3
		]
		guilist [
			guistrut 0.14
			looplist id (sublist $affinityonceid_list $pointaliasslidemin 10) [ //lists max 10 points (more then guislider is active)
				guibody [
					guicenter [ guitext (format "id %1" $id) ]
					guistrut 1
				] [] [] [guistatus_RWP_msg = (format "set a point alias for point id ^fo%1^n^fB/point_ %2" @id $id)]
				guistrut 0.25
			]
		]
		guilist [
			looplist id (sublist $affinityonceid_list $pointaliasslidemin 10) [ //lists max 10 points (more then guislider is active)
				ismultiple_tmp = (ismultipleinlist $affinityid_list $id)
				guilist [
					guibody [
					if (=s (getalias point_@id) "") [
						point_@id = ""
					]
						guifield point_@id -30
					] [] [] [guistatus_RWP_msg = (format "set a point alias for point id ^fo%1^n^fB/point_ %2" @id $id)]
					guistrut 1
					if $point_@id [
						guiimage "textures/guiexit" [point_@id = ""] 0.6
					][ //alias is empty
						guinohitfx [
							guiimage "textures/checkdisable" [] 0.6
						]
					]
					guistrut 1
					guicenter [
						if ($ismultiple_tmp) [ //if current id is multiple
							guibody [ guiimage "textures/hud/point" [] 0.4 [] [] [] [0xFF0000] ] [] [] [guistatus_RWP_msg = (format "^frWarning:^fw more then one point have the id:^fo %1^fw !" @@id)]
						][
							guibody [ guiimage "textures/hud/point" [] 0.4 [] [] [] [0x00FF00] ] [] [] [guistatus_RWP_msg = (format "^fgOnly^fw one point have the id:^fo %1" @@id)]
						]
					]
					guistrut 0.5
					guicenter [
						guieditbodun (? $ismultiple_tmp "show points" "show point") [ //guibutton "show point" and check if there more points with the same id
							entcancel
							entfind "affinity" "*" "*" "*" "*" "*" @id
							entautoview 1
						] [] [] [0xFFFFFF] [guistatus_RWP_msg = (format "show you the %1 with id:^fo %2" (? $ismultiple_tmp "points" "point") @@id)]
					]
				]
			]
		]
	]
	guistrut 1.5
	guibutton "selecte all points" [entfind "affinity" "*" "*" "*" "*" "*" "*"]
	entselcount_tmp = 0
	entloop [entselcount_tmp = (+ $entselcount_tmp 1)]
	if (>= $entselcount_tmp 1) [
		guitext (format "selected ents: %1" $entselcount_tmp)
		if (> $entselcount_tmp 1) [
			guilist [
				guibutton "<--" [entautoview -1]
				guistrut 0.5
				guitext "show ents"
				guistrut 0.5
				guibutton "-->" [entautoview 1]
			]
		][// $entselcount_tmp = 0
			guibutton "show ent" [entautoview]
		]
	]
]
//~~~~~~~~~~~~~~~~~~
editoptions_tab = [
		guistayopen [
		guilist [//submenu row
			guilist [
				guilist [
					bordertabbutton "General" [sub1_editoptions_active = "general General"] 1 "command" "sub1_editoptions_active"
					guistrut 0.5
					bordertabbutton "View" [sub1_editoptions_active = "view View"] 1 "command" "sub1_editoptions_active"
				]
				guistrut 0.4
			]
			guistrut 0.6
		]
		((format "sub1_editoptions_%1" (sublist $sub1_editoptions_active 0 1)) ) //cexecutes the choosen menu
	]
	guivisibletab [guistatus $guistatus_editoptions_msg [3500]]
]

sub1_editoptions_general = [
	guistatus_editoptions_msg = "Editing options"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	guistayopen [ guilist [
		guilist [
			guilist [
				guilist [
					guistrut 0.1; guieditbodun "Float speed:" [] [saycommand /floatspeed""] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "adjust your float speed ((1E-6-1E7)^n^fB/%1" $arg2)]
				]
				guistrut 1
				guilist [ //second column
					guibody [
						guifield floatspeed 6 [] [0xFFFFFF] [] [] [] ""
						guistrut 1
						guiresetbut "floatspeed"
					] [] [saycommand /floatspeed""] [guistatus_editoptions_msg = "adjust your float speed ((1E-6-1E6)^n^fB/floatspeed"]
				]
			]
			guistrut 0.5
			guibobox "enable selection and editing of entities" [entediting] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle outline^n^fb/%1" $arg2)]
			guibobox "snap ents to grid" [entselsnap] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle outline^n^fb/%1" $arg2)]
			guistrut 0.5
			guitext "^faplace new entities:"
			i = (& $entdrop 2)
			guibitfield "on selected area" entdrop 2 
			// next checkbox is just the opposite of this bitfield
			guicheckbox "on camera position" i 0 2 [entdrop (^ $entdrop 2)] 
			guibitfield "drop to ground" entdrop 1
			guistrut 0.5
			guitext (format "^fwcurrent editing grid size: %1" (<< 1 $gridpower))
			guilist [
				guicenter [ guilist [
					guisliderext 23 gridpower 0 (min (- $mapsize 1) 12) [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
				guistrut 1
				guiresetbut "gridpower"
			]
			guitext "^fwundo cache size in MB"
			guilist [
				guicenter [ guilist [
					guisliderext 23 undomegs 1 10 [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
				] ]
				guistrut 1
				guiresetbut "undomegs"
			]
		]
		if (isonline) [ //editlock settings
			guistrut 3
			guibar 8 0 0xFFFFFF
			guistrut 3
			guicenter [
				islocked = (? (!= (getmastermode) 2) 0 2) //if mastermode is 2 its 2 else 0
				guilist [
					looplist locktmp "edit spawn" [
						curmodelock = (? (=s $locktmp "edit") "editlock" "spawneditlock")
						guilist [
							guicenter [ guibody [guitext $locktmp [] [0x30ACAC]] [] [] [guistatus_editoptions_msg = (format "allow %1ing only for specific auth levels (when mastermode 2 (locked))" $locktmp)] ]
							i = 7
							looplist priv [founder developer administrator operator moderator supporter player none] [
								guibody [
									if (=s $locktmp "spawn") [guistrut 1] //guistrut btw edit and spawn
									guiimage [textures/privs/@priv] [] 0.8 1 "" [] (? (= $islocked 2) (? (< $i $$curmodelock) "0xFF0000" "0x00FF00") "0xB0B0B0")//check if its mastermode 2 then coloured else grey
								] [//guibody action
									if (= $islocked 2) [//
										@@curmodelock @@i
										looplist j (listdel (listclients 0) (listclients 0 2)) [	//non ai cn list; spectate all player which havent the required level, because if not they can edit until they go out of editmode
											if (getclientpriv $j @@@i) [] [spectator 1 $j]
										]
									][
										echo "set mastermode to 2 (locked) first^n^f[0xffde00]/mastermode^f[0xFFA54F] 2"
									]
								] [saycommand /mastermode 2";" @@curmodelock @i] [guistatus_editoptions_msg = (? (!= @i 0) (format "allows %1ing only for %2s or higher (when mastermode 2 (locked))^n^fB/editlock %3" @locktmp @priv @i) (format "allows %1ing for everybody (when mastermode 2 (locked))^n^fB/editlock 0" @locktmp)) ]
								i = (- $i 1)
							]
							guiresetbut $curmodelock [guistatus_editoptions_msg = (format "reset^fB %1^fw to ^fo %2" $curmodelock)]
						]
						guistrut 2
					]
				]
				//long version
				//guilist [
				//	guilist [
				//		guicenter [ guibody [guitext "edit"] [] [] [guistatus_editoptions_msg = (format "allow editing only for specific auth levels (when mastermode 2 (locked))")] ]
				//		i = 7
				//		looplist priv [founder developer administrator operator moderator supporter player none] [
				//			guibody [
				//				guiimage [textures/privs/@priv] [] 0.8 1 "" [] (? (= $islocked 2) (? (< $i $editlock) "0xFF0000" "0x00FF00") "0xB0B0B0")//check if its mastermode 2 then coloured else grey
				//			] [//guibody action
				//				if (= $islocked 2) [//
				//					editlock @@i
				//					looplist j (listdel (listclients 0) (listclients 0 2)) [	//non ai cn list; spectate all player which havent the required level, because if not they can edit until they go out of editmode
				//						if (getclientpriv $j @@@i) [] [spectator 1 $j]
				//					]
				//				][
				//					echo "set mastermode to 2 (locked) first^n^f[0xffde00]/mastermode ^f[0xFFA54F]2"
				//				]
				//			] [saycommand /mastermode 2";" editlock @i] [guistatus_editoptions_msg = (? (!= @i 0) (format "allows editing only for %1s or higher (when mastermode 2 (locked))^n^fB/editlock %2" @priv @i) "allows editing for everybody (when mastermode 2 (locked))^n^fB/editlock 0")]
				//			i = (- $i 1)
				//		]
				//	]
				//	guistrut 2
				//	guilist [
				//		guicenter [ guibody [guitext "spawn"] [] [] [guistatus_editoptions_msg = (format "allow spawning only for specific auth levels (when mastermode 2 (locked))")] ]
				//		i = 7
				//		looplist priv [founder developer administrator operator moderator supporter player none] [
				//			guibody [
				//				guiimage [textures/privs/@priv] [] 0.8 1 "" [] (? (= $islocked 2) (? (< $i $spawneditlock) "0xFF0000" "0x00FF00") "0xB0B0B0")//check if its mastermode 2 then coloured else grey
				//			] [//guibody action
				//				if (= $islocked 2) [//
				//					spawneditlock @@i
				//					looplist j (listdel (listclients 0) (listclients 0 2)) [	//non ai cn list; spectate all player which havent the required level, because if not they can edit until they go out of editmode
				//						if (getclientpriv $j @@@i) [] [spectator 1 $j]
				//					]
				//				][
				//					echo "set mastermode to 2 (locked) first^n^f[0xffde00]/mastermode ^f[0xFFA54F]2"
				//				]
				//			] [saycommand /mastermode 2";" spawneditlock @i] [guistatus_editoptions_msg = (? (!= @i 0) (format "allows spawning only for %1s or higher (when mastermode 2 (locked))^n^fB/spawneditlock %2" @priv @i) "allows spawning for everybody (when mastermode 2 (locked))^n^fB/spawneditlock 0")]
				//			i = (- $i 1)
				//		]
				//	]
				//]
				guistrut 0.4
				guibody [
					guistrut 2
					guicheckbox "lock" islocked 2 0 [//guicheckbox action
						mastermode $islocked
						looplist i (listdel (listclients 0) (listclients 0 2)) [	//non ai cn list; spectate all player which havent the required level, because if not they can edit until they go out of editmode
									if (getclientpriv $i $editlock) [] [spectator 1 $i]
						]
						looplist i (listdel (listclients 0) (listclients 0 2)) [	//non ai cn list; spectate all player which havent the required level, because if not they can edit until they go out of editmode
									if (getclientpriv $i $spawneditlock) [] [spectator 1 $i]
						]
					]
				] [] [] [guistatus_editoptions_msg = (? (= $islocked 2) "disable mastermode 2 (locked)^n^fB/mastermode 0" "enable mastermode 2 (locked)^n^fB/mastermode 2") ] 
			]
		]
	] ]
]
sub1_editoptions_view = [
	guistatus_editoptions_msg = "View options"
	guibar 10 0 0xFFFFFF
	guistrut 0.5

	guibobox "toggle paste grid" [showpastegrid] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle outline^n^fb/%1" $arg2)]
	guibobox "toggle cursor grid" [showcursorgrid] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle outline^n^fb/%1" $arg2)]
	guibobox "toggle selection grid" [showselgrid] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle outline^n^fb/%1" $arg2)]
	guistrut 0.5
	guibobox "show material volumes" [showmat] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "show material volumes^n^fb/showmat")]
	guibobox "toggle allfaces texture mode" [allfaces] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle outline^n^fb/%1" $arg2)]
	guistrut 0.5
	guibobox "toggle fullbright" [fullbright] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle fullbright^n^fb/%1" $arg2)]
	guibobox "toggle wireframe" [wireframe] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle wireframe^n^fb/%1" $arg2)]
	guibobox "toggle blank geometry" [blankgeom] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle blank geometry^n^fb/%1" $arg2)]
	guilist [
		guilist [
			guibobox "^fwtoggle outline" [outline] [] [] [] [guistatus_editoptions_msg = (format "toggle outline^n^fb/%1" $arg2)]
		]
		guistrut 1
		guilist [
			guibackground $outlinecolour $guibgblend [] [] 0 //makes the background coloured as the current colour because the button needs to be visible even when its black
			guistrut 0.05
			guilist [
				guistrut 0.3
				guieditbodun "outlinecolour" [ice_pickcolour outlinecolour] [saycommand /outlinecolour""] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "Set the colour of the outline^n^fB/%1" $arg2)]
				guistrut 0.3
			]
			guistrut 0.05
		]
	]
	guistrut 0.5
	guibobox "toggle edit radar" [showeditradar] [] [] [0xFFFFFF] [guistatus_editoptions_msg = (format "toggle edit radar^n^fb/%1" $arg2)]
	guiradio "sectional compass" editradarstyle 0
	guiradio "compass-distance " editradarstyle 1
	guiradio "full hud" editradarstyle 2
	guiradio "minimap" editradarstyle 3
	guistrut 0.5
	guilist [
		guitext "minimap view distance (zoom out)"
		guistrut 1
		guiradio "full map size" editradardist 0
	]
	guilist [
		guisliderext 23 editradardist 16 (<< 1 $mapsize) [] [] [] [0xC0C0C0] [] [0xFFFFFF] //additional guislider for fast changing
	]
]
//~~~~~~~~~~~~~~~~~~


//other sub guis
newgui ice_pickcolour [ guistayopen [ // an updated pickcolour with buttons in the middle
	// scurvar is a command / game variables that takes a hex colour value
	guiheader "pick a colour"
	guifont "emphasis" [
		guitext (format "pick a colour for the variable ^fB/%1" $scurvar)
	]
	if (= $guipasses 0) [ hex = $$scurvar ]
	guistrut 1
	guilist [
		guibody [ guilist [
		guihexpreview (getvardef $scurvar) "default"
		] ] [hex = (getvardef $scurvar)]
		guispring 1
		guibody [ guilist [
		guihexpreview $$scurvar "current"
		] ] [hex = $$scurvar]
		guispring 1
		guihexpreview $hex "new"
		guispring 1
		guilist [
			guirgbsliders hex
		]
	]
	guistrut 1
	guicenter [guitext "^faclick a colour preset below and/or use the RGB-sliders to choose a new colour"] 
	guistrut 1
	guipalette 0.65
	guistrut 0.5
	guifont "emphasis" [ guicenter [ guilist [ guilist [
		guibutton "^fgOK" [@scurvar @hex; cleargui 1] 
		guistrut 3
		guibutton "^frCancel" [cleargui 1]
	] ] ] ]
] ]
ice_pickcolour = [ scurvar = $arg1; showgui ice_pickcolour ]

newgui materialmenu [//a small material menu; TWO guitabs
	guistatus_materialmenu_msg = (format "Open this menu everytime with %1" (dobindsearch "showgui materials 1" edit) )
	guiheader "Material"
	if (&& (< $matfilternum 0) (> $matfilternum 19)) [matfilternum = 0] //test if the matfilternum is one of the available filters
	if (&& (< $geofilternum 0) (< $geofilternum 5)) [geofilternum = 0] //test if the geofilternum is one of the available filters

	guistayopen [ guibody [ //show material volumes on/off
		guicheckbox "show material volumes" showmat
		guistrut 1
		guibutton (dobindsearch "showmat (= $showmat 0); if (= $showmat 0) [echo showmat OFF] [ echo showmat ON]" edit)
	] [if $showmat [showmat 1; echo "showmat ON"] [showmat 0; echo "showmat OFF"]] [saycommand /@showmat] [guistatus_materialmenu_msg = "show material volumes^n^fB/showmat"] ]
	guistrut 0.5
	if (!= $matfilternum 0) [
		matfilter = (sublist "air alpha water lava clip noclip aiclip death ladder glass water2 water3 water4 lava2 lava3 lava4 glass2 glass3 glass4" (- $matfilternum 1) 1)
	][
		matfilter = ""
	]
	looplist mat "air alpha water lava clip noclip aiclip death ladder glass" [//material list
		//guibar 8 0 0xFFFFFF
		if (=s $mat $matfilter ) [ //when the material and the matfilternum are the same then the guibutton is not clickable
			guinohitfx [
				guibody [
					guitext @mat [] [] [] [0x505050]
					guispring 1
					guibutton (dobindsearch [editmat @mat] edit)
				] [] [] [guistatus_materialmenu_msg = "This material isnt available due to material filter selection"]
			]
		][ //when material and matfilternum arent the same
			guibody [
				guibutton @mat [] [] [] [0xFFFFFF]
				guispring 1
				guibutton (dobindsearch [editmat @mat] edit)
			] [editmat @mat @matfilter @geofilternum] [saycommand /editmat @mat $matfilter $geofilternum] [guistatus_materialmenu_msg = (format "Set the selected cubes to ^fo%1 ^fwmaterial" @mat)]
		]
	]
	guibar 8 0 0xFFFFFF
	guibar 8 0 0xFFFFFF
	guicenter [
		looplist mat [water lava glass] [ //for the numbered material lopplist
			guilist [
				looplist j [2 3 4] [ //adds the numbered material
					guibody [
						guibutton @mat@j [] [] [] [0xFFFFFF]
					] [editmat @mat@j @matfilter @geofilternum] [saycommand /editmat @mat@j] [guistatus_materialmenu_msg = (format "Set the selected cubes to ^fo%1 ^fwmaterial" @mat@j)]
				]
			]
			guistrut 3
		]
	]
	guivisibletab [guistatus $guistatus_materialmenu_msg]

guitab "Filter"
	guistatus_materialmenu_filter_msg = ""
	guilist [
		guilist [
			guicenter [ guitext "Material filter" [] [0x30ACAC] ]
			matfiltername_temp = (? (= $matfilternum 0) (result "filter off") (result (sublist "air alpha water lava clip noclip aiclip death ladder glass water2 water3 water4 lava2 lava3 lava4 glass2 glass3 glass4" (- $matfilternum 1) 1)) )
			guicenter [ guitext (format "(%1)" $matfiltername_temp)]
			guistrut 0.2
			//material filter list, beginning with 0 until 19 is: "no_filter(0) air(1) alpha(2) water(3) lava(4) clip(5) noclip(6) aiclip(7) death(8) ladder(9) glass(10) water2(11) water3(12) water4(13) lava2(14) lava3(15) lava4(16) glass2(17) glass3(18) glass4(19)"
			guibody [ guiradio "filter off" matfilternum 0 [] [0xEEBBBB] ] [] [] [guistatus_materialmenu_filter_msg = "material ^fofilter off"] //guiradio "filter off"
			loop i 10 [//material list; creating the matfilternum from 1 to 10
				guibody [
					name_temp = (sublist "air alpha water lava clip noclip aiclip death ladder glass" $i 1)
					guiradio $name_temp matfilternum (+ $i 1) [] //(+ $i 1) because of excluding "filter off(0)"
				] [] [] [guistatus_materialmenu_filter_msg = (format "limit changes to ^fo%1 ^fwmaterial" $name_temp)]
			]
		]
		guistrut 0.5
		guibar 8 0 0xFFFFFF
		guistrut 0.5
		guilist [
			guicenter [ guitext "Geometry filter" [] [0x30ACAC] ]
			guicenter [ guitext (format "(%1)" (stringreplace (sublist "filter_off non-empty empty not_entirely_solid entirely_solid" $geofilternum 1) "_" " ")) ]
			guistrut 0.2
			guibody [ guiradio "filter off" geofilternum 0 [] [0xEEBBBB] ] [] [] [guistatus_materialmenu_filter_msg = "geometry^fo filter off"] //guiradio "filter off"
			loop i 4 [//possibilities for the geometry filter; {0 = normal (filter off), 1 = non-empty, 2 = empty, 3 = not entirely solid, 4 = entirely solid}
				name_temp = (stringreplace (sublist "non-empty empty not_entirely_solid entirely_solid" $i 1) "_" " ")
				guibody [
					guiradio $name_temp geofilternum (+ $i 1) //because of excluding "filter off"
				] [] [] [guistatus_materialmenu_filter_msg = (format "limit changes to ^fo%1 ^fwgeometry" $name_temp)]
			]
		]
	]
	guistrut 0.5
	guicenter [ guistayopen [ guieditbodun "More filters" [sub1_material_active = "filter Filter"; cleargui; showgui editing_gui 2] [] [] [0xFFFFFF] [guistatus_materialmenu_filter_msg = "open an extended filter menu"] ] ]
	guistrut 0.5
	guifontext 38 [
		guitext "Limits the area of the changes ^f[0xFF9999]only for^fw material"
		guitext"or geometry (or combinations with them) which"
		guitext "is set in the filters"
	]
	guivisibletab [guistatus $guistatus_materialmenu_filter_msg [2000]]
]

newgui chosemusic [ guistayopen [ //you can hear music and chose them as mapmusic
	guiheader "music menu"
	guistatus_msg = "music menu"
	loopfiles i "sounds/music" "ogg" [
		guilist [ 
			guieditbodun $i [music music/@i] [] $arrowrighttex [0xFFFFFF] [guistatus_msg = "hear this song"]
			guispring 1
			guieditbodun "" [mapmusic sounds/music/@i; cleargui 1] [] $editingtex [] [guistatus_msg = "use this music ^fB/mapmusic"]
		]
	]
	guilist [
		guieditbodun clear [music ""] [] $warningtex [0xFFFFFF] [guistatus_msg = "stop music"]
		guispring 1
		guieditbodun "" [mapmusic ""; cleargui 1] [] $editingtex [] [guistatus_msg = "use no music ^fB/mapmusic"]
	]
	guistatus $guistatus_msg
] ]

prevlistindex = 0
newgui prev_mapversion [
	guiheader "Revision manager"
	if $prevvermaps_list [//if previous revisions are found
		prevvermaps_list = (sortlist $prevvermaps_list a b [>f $a $b]) //sort the list because its possible that there are revisions over 9999; and in the "wrong" way because the newest should be above (the highest revisions)
		guitext "Load revision:"
		guistrut 0.5
		guilist [
			guistrut 0.5
			guilist [
				looplist i (sublist $prevvermaps_list $prevlistindex 16) [ //lists all revisions
					guiradio ($i) chovers $i //chovers is the choosen version
				]
			]
			guistrut 1.5
			guislider prevlistindex 0 (max 0 (- (listlen $prevvermaps_list) 16)) [] 1 1 //the max showns rev are 16, if its lower the slider doesnt need to slide, its zero then
			case (stringlen $chovers //adds for the image preview the zeros again, needed in the file
			) 3 [
				chovers = (concatword "0" $chovers)
			] 2 [
				chovers = (concatword "00" $chovers)
			] 1 [
				chovers = (concatword "000" $chovers)
			]
			guistrut 0.5
			guicenter [
				guinohitfx [ guiimage (format "backups\maps\%1.r%2" $mapshortname $chovers) [] 8 1 "textures/nothumb" ] //loads the image, sometimes there are black images
			]
		]
		guistrut 1
		guicenter [ guifontext 62 [
			if $chovers [
				guibutton "^fgOk" [savewarnchk [edit (format "backups\maps\%1.r%2" $mapshortname $chovers)]]
			][
				guinohitfx [
					guibutton "^faOk" []
				]
			]
			guistrut 5
			guibutton "^frCancel" [cleargui; showgui editing_gui]
		] ]
	][ //if no backuped revision is found
		guione [
			guitext "No previous revisions found."
		]
		guistrut 1
		guicenter [guibutton "^fgOk" [cleargui; showgui editing_gui] ]
	]
][
	if (= $guipasses 0) [ //deletes the choosen backup revision every time again
		chovers = ""
		
		//getting the previous versions
		mapshortname = $mapname //prepare cutting the name
		while [!= (stringstr $mapshortname "/") -1] [mapshortname = (substring $mapshortname (+ (stringstr $mapshortname "/") 1) (stringlen $mapshortname))] //cut the name
		mapshortnamelen = (stringlen $mapshortname)//to get the length only once
		prevvermaps_list = "" //prepare loop
		loopfiles i "backups\maps" mpz [//use only mpz in the map backups
			if (stringncmp (concatword $mapshortname ".r") $i (+ $mapshortnamelen 2)) [ //filters only the backups of the current map; limitation there are no "shit" mapnames with a ".r"
				prevvermaps_list = (concat $prevvermaps_list (substring $i (+ $mapshortnamelen 2) (stringlen $i)) )//adds only the number to the revision list
			]
		]
	]
]

newgui newmapshot [ //will make a new mapimage
	guiheader " "
	showwaypoints_temp = ($showwaypoints)
	showroute_temp = ($routeid)
	guilist [
		guibutton "^fgSet" [routeid -1; showwaypoints 0; savemapshot (format "%1" $mapname); showwaypoints $showwaypoints_temp; routeid $showroute_temp; showgui editing_gui 1; reloadtex (format "%1.png" $mapname)]
		guistrut 2
		guibutton "^frCancel" [showgui editing_gui 1]
	]
]
// do
showgui editing_gui 1