//HINT! ATM theres no action detection of guibodys so the own buttons dont get coloured

// init vars
	//menu vars
menurowsactive = "info"

menu1infoactive = ""
menu1testactive = ""
	//vars
count_temp = -1
colaction = ""

// commands (cmd)
buttonsrollover_test = [
	if $guirolloveraction [
		colaction = $guirolloveraction
		count_temp = -1
	][
		count_temp = (+ $count_temp 1)
		if $count_temp [
			colaction = ""
			count_temp = -1
		]
	]
	echo $yguirolloveraction
]
bordertabbutton = [//$arg1 = name; $arg2 = buttonaction; $arg3 = 0 (horiz), = 1 (vertic), $arg4 = buttonfontsize
	if (=s $menurowsactive $arg1) [
		bordertabbuttoncolour = "0xFFFFFF"
		actguibordercol = "0xFFFFFF"
	][
		bordertabbuttoncolour = "0x808080"
		actguibordercol = "0x000000"
	]
	if (&& (=s $colaction $arg2) (!=s $menurowsactive $arg1)) [//if the button is rollovered
		actguibordercol = "0xFF0000"
	]
	guilist [ guifont $arg4 [
		guibackground $guifieldbgcolour $guifieldbgblend $actguibordercol $guifieldborderblend 1
		if $arg3 [//button horizontal
			guistrut 0.4
			guilist [
				guistrut 0.1
				if (=s $menurowsactive $arg1) [//when button active nohitguifx
					guinohitfx [
						guibutton $arg1 $arg2 [] [] $bordertabbuttoncolour
					]
				][
					guibutton $arg1 $arg2 [] [] $bordertabbuttoncolour
				]
				guistrut 0.1
			]
			guistrut 0.4
		][//button vertical
			guilist [
				guistrut 0.4
				guilist [
					guistrut 0.1
				if (=s $menurowsactive $arg1) [//when button active nohitguifx
					guinohitfx [
						guibutton $arg1 $arg2 [] [] $bordertabbuttoncolour
					]
				][
					guibutton $arg1 $arg2 [] [] $bordertabbuttoncolour
				]
					guistrut 0.1
				]
				guistrut 0.4
			]
		]
	] ]
]
				//actions need [....] in the definition
guitextbutton = [//$arg1 = name; $arg2 = action; $arg3 = colour; $arg4 = alt-act; $arg5 = icon; $arg6 = on hover
	if (=s $colaction $arg2) [//if the button is rollovered
		guitextbutton_col = "0xFF0000"
	][
		guitextbutton_col = $arg3
	]
	guibody [guitext $arg1 $arg5 $colour] $arg2 $arg4 $arg6
]
			//for using the inputgui use this schema: (<what to do with the result of inputgui> (inputgui <header message> <which var should be changed> <guistatus msg>) )
inputgui = [//$arg1 = header message; $arg2 = input var; $arg3 = what to do when you want to change it; $arg4 = special message, e.g. hints; result = when ok the written content
	inputgui_result = ""//guifield temp var for saving
	input_temp_var = $arg2
	input_temp_prev = $$arg2// content of the var/cmd
	inputgui_exec = $arg3//content will execute when pressing ok
	input_temp_msg = $arg4
	newgui input_gui [
		guiheader @arg1
		guicenter [
			guitext (format "%1: %2" $input_temp_var $input_temp_prev)
		]
		guistrut 0.5
		guicenter [
			guifield inputgui_result 30 [] [0xFFFFFF] [1] [] [] ""
		]
		guistrut 0.5
		guicenter [ guifont "command" [
			guibutton "^fgOK" [
				(inputgui_exec)
				cleargui 1
			]
			guistrut 3
			guibutton "^frCancel" [cleargui 1]
		]]
		if $input_temp_msg [
			//guistrut 1//this if instead guistatus guitext
			//guibar
			guifont "little" [
				guistatus $input_temp_msg [1000]
			]
		]
	]
]
dectohex = [//$arg1 = decimal number; result = hex number
	intres_temp = $arg1
	dectohex_result = ""
	while [!= $intres_temp 0] [
		addhex_temp = (mod $intres_temp 16)
		if (> $addhex_temp 9) [
			case ($addhex_temp
				) 10 [ addhex_temp = "A"
				] 11 [ addhex_temp = "B"
				] 12 [ addhex_temp = "C"
				] 13 [ addhex_temp = "D"
				] 14 [ addhex_temp = "E"
				] 15 [ addhex_temp = "F"
			]
		]
		dectohex_result = (concatword $addhex_temp $dectohex_result)
		intres_temp = (div $intres_temp 16)
	]
	result $dectohex_result
]

// gui tabs
menu1_info = [
	guilist [
		if $maptitle [
			guitextbutton $maptitle [(inputgui "Set mapname" maptitle [maptitle $inputgui_result]); showgui input_gui] [0xFFFFFF]//inputgui: cmd
		][
			guitextbutton "<Name>" [(inputgui "Set mapname" maptitle [maptitle $inputgui_result]); showgui input_gui] [0xFFFFFF]//inputgui: cmd
		]
		guitext "^fa created by "
		if $mapauthor [
			guitextbutton $mapauthor [(inputgui "Set mapauthor" mapauthor [mapauthor $inputgui_result]); showgui input_gui] [0xFFFFFF]//inputgui: cmd
		][
			guitextbutton "<Name>" [(inputgui "Set mapauthor" mapauthor [mapauthor $inputgui_result]); showgui input_gui] [0xFFFFFF]//inputgui: cmd
		]
	]
	guitext (format "^faRevision: ^fw%1" (maprevision))
	guitext (format "^faSize: ^fw%1" (mapsize))
	guilist [
		guitext "^faFile: "
		guitextbutton (format "^fw%1" $mapname) [
			(inputgui "Set mapfile" mapname [
				inputgui_result = (stringreplace $inputgui_result " " "_")//prevent spaces in the name
				if (= (stringstr $inputgui_result "/") -1) [
					(mapname (concatword "maps/" $inputgui_result))
				][
					(mapname $inputgui_result)
				]
			] "The map will be saved in the user directory. For sub folder use this schema: folder/folder/.../mapfilename^nIf no folder is given it will be saved under maps/"); showgui input_gui//inputgui: cmd
		] [0xFFFFFF]
	]
	guitext (format "^faVersion: ^fw%1" (mapversion))
]
menu1_test = [
	guibutton "Test" [] [] "textures/chat"
]

mapedit_tab = [
	guistayopen [
		guilist [//first menu row
			guibackground 0x707070 $guifieldbgblend $guibordercolour $guifieldborderblend 1
			guistrut 0.6
			guilist [
				guistrut 0.4
				guilist [
					bordertabbutton "info"	[menurowsactive = "info"] 0 "command"//cmd
					guistrut 0.5
					bordertabbutton "test" [menurowsactive = "test"] 0 "command"//cmd
				]
				guistrut 0.4
			]
			guistrut 0.6
		]
		guistrut 0.2
		guibar 0xFFFFFF
		((concatword "menu1_" $menurowsactive)) //cexecutes the choosen menu
	]
	buttonsrollover_test	//cmd; when roll over the border gets red of the borderbuttons
] 
//~~~~~~~~~~~~~~~~~~
another_tab_tab = [

]

// gui structure
newgui editing_gui [
	guiheader "map"
		[mapedit_tab]
	guitab "anothzer tab"
		[another_tab_tab]
]

// do
showgui editing_gui