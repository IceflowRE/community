// init vars
	//menu vars
//NOTE: sub1_mapedit_active "first is the name of the submenu command; the second the name of the button with _ instead of spaces, its needed to detect which button is active for different colours
sub1_material_active = "set_material Set_material"
sub1_mapedit_active = "info Info"

	//vars


// commands (cmd)
bordertabbutton = [//$arg1 = name; $arg2 = buttonaction; $arg3 = 0 (horiz), = 1 (vertic), $arg4 = buttonfontsize; $arg5 = which tabmenu for checking if its active or not
	if (=s (stringreplace (sublist $$arg5 1 1) "_" " ") $arg1) [isactive = 1] [isactive = 0]
	if $isactive [//colour for active not active
		bordertabbuttoncolour = "0xFFFFFF"
		actguibordercol = "0xFFFFFF"
	][
		bordertabbuttoncolour = "0x808080"
		actguibordercol = "0x000000"
	]
	if (&~ (=s $detectedaction $arg2) $isactive) [//if the button is rollovered
		actguibordercol = "0xFF0000"
	]
	guilist [ guifont $arg4 [
		guibackground $guifieldbgcolour $guifieldbgblend $actguibordercol $guifieldborderblend 1
		if $arg3 [//button horizontal
			guistrut 0.1
			guilist [
				guistrut 0.4
				if $isactive [//when button active nohitguifx
					guinohitfx [
						guibutton $arg1 $arg2 [] [] $bordertabbuttoncolour
					]
				][
					guibutton $arg1 $arg2 [] [] $bordertabbuttoncolour
				]
				guistrut 0.4
			]
			guistrut 0.1
		][//button vertical
			guilist [
				guistrut 0.1
				guilist [
					guistrut 0.4
				if $isactive [//when button active nohitguifx
					guinohitfx [
						guibutton $arg1 $arg2 [] [] $bordertabbuttoncolour
					]
				][
					guibutton $arg1 $arg2 [] [] $bordertabbuttoncolour
				]
					guistrut 0.4
				]
				guistrut 0.1
			]
		]
	] ]
	
]
bordertabbuttonrollover_test = [//test if you onhover over the bordertabbuttons
	if $guirolloveraction [
		detectedaction = $guirolloveraction
		buttonsrollover_count = (+ $guipasses 2)
	][
		if (= $buttonsrollover_count $guipasses)[//deletes only after two no guirolloveractions behind
			detectedaction = ""
			buttonsrollover_count = (+ $guipasses 2)
		]
	]
]
guibodun = [//$arg1 = name; $arg2 = action; $arg3 = alt-act; $arg4 =  icon; $arg5 = colour; $arg6 = onhover
	guibody [
		guibutton $arg1 [] [] $arg4 $arg5
		if (dobindsearch [@arg2] edit) [
			guistrut 1
			guibutton (dobindsearch [@arg2] edit)
		]
	] $arg2 $arg3 $arg6
]
			//for using the inputgui use this schema: (<what to do with the result of inputgui> (inputgui <header message> <which var should be changed> <ok button execute> <guistatus msg>) )
			//WARNING! Ok Button needs in the action even the cleargui 1
inputgui = [//$arg1 = header message; $arg2 = input var; $arg3 = what to do when you want to change it; $arg4 = Cancel Button; $arg4 = special message, e.g. hints; result = when ok the written content
	input_temp_var = $arg2
	inputgui_prev = $$arg2// content of the var/cmd
	inputgui_result = ""
	inputgui_exec = $arg3//content will execute when pressing ok
	input_temp_msg = $arg4
	newgui input_gui [
		guiheader @arg1
		guitext (format "^fwCurrent: ^fC%1" $inputgui_prev) [] [] [] [5000]
		guistrut 0.5
		guicenter [
			guifield inputgui_result -30 [] [0xFFFFFF] [1] [] [] ""
		]
		guistrut 0.5
		guicenter [ guifont "command" [
			guibutton "^fgOK" [
				(inputgui_exec)
			]
			guistrut 3
			guibutton "^frCancel" [cleargui 1]
		]]
		if $input_temp_msg [
			guifont "little" [
				guistatus $input_temp_msg [1000]
			]
		]
	]
	showgui input_gui
]
dectohex = [//$arg1 = decimal number; result = hex number
	intres_temp = $arg1
	dectohex_result = ""
	while [!= $intres_temp 0] [
		addhex_temp = (mod $intres_temp 16)
		if (> $addhex_temp 9) [
			case ($addhex_temp
				) 10 [ addhex_temp = "A"
				] 11 [ addhex_temp = "B"
				] 12 [ addhex_temp = "C"
				] 13 [ addhex_temp = "D"
				] 14 [ addhex_temp = "E"
				] 15 [ addhex_temp = "F"
			]
		]
		dectohex_result = (concatword $addhex_temp $dectohex_result)
		intres_temp = (div $intres_temp 16)
	]
	result $dectohex_result
]
			//makes a tabelle with a left part and a right part
guisplit2 = [//$arg1 = left part; $arg2 = right part; $arg3 = onhover
	guibody [
		guilist [
			guistrut 0.1
			(@arg1)
		]
		guistrut 1
		guispring 1
		guilist [
			guistrut 25 1
			(@arg2)
		]
	] [] [] [@arg3]
]
			//extended guislider, adds an option for the length
guisliderext = [//$arg1 = length; $arg2 = var; $arg3 =  min; $arg4 =  max; $arg5 =  onchange; $arg6 =  reverse; $arg7 =  scroll; $arg8 =  colour; $arg9 =  style; $arg10 =  slidercolour
	guilist [
		guistrut 0.2
		guilist [ guilist [
			guistrut $arg1 1
			guislider $arg2 $arg3 $arg4 $arg5 $arg6 $arg7 $arg8 $arg9 $arg10
		] ]
	]
]

newgui chosemusic [ guistayopen [
	guiheader "music menu"
	guistatus_msg = "music menu"
	loopfiles i "sounds/music" "ogg" [
		guilist [ 
			guibodun $i [music music/@i] [] $arrowrighttex [0xC0C0C0] [guistatus_msg = "hear this song"]
			guispring 1
			guibodun "" [mapmusic sounds/music/@i; cleargui 1] [] $editingtex [] [guistatus_msg = "use this music ^fB/mapmusic"]
		]
	]
	guilist [
		guibodun clear [music ""] [] $warningtex [0xC0C0C0] [guistatus_msg = "stop music"]
		guispring 1
		guibodun "" [mapmusic ""; cleargui 1] [] $editingtex [] [guistatus_msg = "use no music ^fB/mapmusic"]
	]
	guistatus $guistatus_msg
] ]

// gui tabs

sub2_mapedit_info = [
	guistatus_msg = "Map main menu - info"
	guibar 5 0 0xFFFFFF
	guistrut 0.5
	
	guilist [
		if $maptitle [
			guibodun $maptitle [(inputgui "Set mapname" maptitle [maptitle $inputgui_result; cleargui 1])] [] [] [0xC0C0C0] [guistatus_msg = "change the maptitle^n^fB/maptitle"]//inputgui: cmd
		][
			guibodun "<Name>" [(inputgui "Set mapname" maptitle [maptitle $inputgui_result; cleargui 1])] [] [] [0xC0C0C0] [guistatus_msg = "change the maptitle^n^fB/maptitle"]//inputgui: cmd
		]
		guitext "^fw created by "
		if $mapauthor [
			guibodun $mapauthor [(inputgui "Set mapauthor" mapauthor [mapauthor $inputgui_result; cleargui 1])]  [] [] [0xC0C0C0] [guistatus_msg = "change the mapauthor^n^fB/mapauthor"]//inputgui: cmd
		][
			guibodun "<Name>" [(inputgui "Set mapauthor" mapauthor [mapauthor $inputgui_result; cleargui 1])] [] [] [0xC0C0C0] [guistatus_msg = "change the mapauthor^n^fB/mapauthor"]//inputgui: cmd
		]
		guispring 1
	]
	guilist [
		guilist [
			guistrut 0.5
			guibody [
				guiimage (format "%1.png" $mapname) [] [10] [0] "textures/nothumb"
			] [cleargui; savemapshot (format "%1.png" $mapname); showgui editing_gui] [] [guistatus_msg = "click to make a new mapshot^n^fB/savemapshot"]
		]
		guistrut 0.5
		guibar 5 0 0xFFFFFF
		guistrut 0.5
		guilist [
			guistrut 0.3
			guitext (format "^fwRevision: ^fa%1" (maprevision))
			guitext (format "^fwMap size: ^fa%1" (mapsize))
			guitext (format "^fwBounding box size: ^fa%1" (<< 1 $mapsize))
			guilist [
				guitext "^fwFile: "
				guibodun $mapname [
					(inputgui "Set mapfile" mapname [//inputgui: cmd
						inputgui_result = (stringreplace $inputgui_result " " "_")//prevent spaces in the name
						if $inputgui_result [
							if (= (stringstr $inputgui_result "/") -1) [//when no subfolder is found
								(mapname (concatword "maps/" $inputgui_result))
							][
								(mapname $inputgui_result)
							]
						][
							newgui info [guiheader "info"; guione [ guitext "No path given. ^frNothing^fw changed..." ] ]; showgui info
							sleep 2000 [cleargui 2]
						]
					] "The map will be saved in the user directory. For sub folder use this schema: folder/folder/.../mapfilename^nIf no folder is given it will be saved under maps/")
					showgui input_gui
				] [] [] [0xC0C0C0] [guistatus_msg = "change the mapname^n^fB/mapname"]
			]
			guitext (format "^fwmap file format Version: ^fa%1" (mapversion))
			guilist [
				guitext "^fwMapmusic: "
				if $mapmusic [
					guibodun $mapmusic [showgui chosemusic] [] [] [0xC0C0C0] [guistatus_msg = "change mapmusic^n^fB/mapmusic"]//inputgui: cmd
				][
					guibodun "<Music>" [showgui chosemusic] [] [] [0xC0C0C0] [guistatus_msg = "chose a mapmusic^n^fB/mapmusic"]//inputgui: cmd
				]
			]
		]
	]
]
sub2_mapedit_save_and_load = [
	guistatus_msg = "Save and load"
	guibar 5 0 0xFFFFFF
	guistrut 0.5

	guibodun "^faSave map" [savemap] [] [] [] [guistatus_msg = "Saves the map. ^n^fB/savemap"]
	guibodun "^faSave map with waypoints" [savemap; savewaypoints] [] [] [] [guistatus_msg = "Saves the map with waypoints.^n^fB/savemap; savewaypoints"]
	guibodun "^faSave waypoints" [savewaypoints] [] [] [] [guistatus_msg = "Saves only the waypoints.^n^fB/savewaypoints"]
	guibodun "^faSave as final version" [fullbright 0; calclight 1; texturecull; savemap; savewaypoints] [] [] [] [guistatus_msg = "Calc light and clear all unused textures from map cfg and saves the map. ^n^fB/fullbright 0; calclight 1; texturecull; savemap"]
	guistrut 0.3
	if (isonline) [
		guibodun "^faVote map again" [edit $mapname] [] [] [] [guistatus_msg = "Vote or force the current map as edit^n^fB/edit"]
	][
		guibodun "^faReload map" [edit $mapname] [] [] [] [guistatus_msg = "Reload the current map^n^fB/edit"]
	]
]
sub2_mapedit_map_settings = [
	guistatus_msg = "Map settings"
	guibar 5 0 0xFFFFFF
	guistrut 0.5

	guisplit2 [guitext "Numplayers:"] [
		guilist [
			guifield numplayers 3 [] [0xFFFFFF] [] [] [] ""
			guistrut 1
			guilist [
				guistrut 0.12
				if (= $numplayers (getvardef numplayers 1)) [
					guinohitfx [
						guiimage "textures/checkdisable" [] 0.6
					]
				][
					guiimage "textures/guiexit" [numplayers (getvardef numplayers 1)] 0.6
				]
			]
			guistrut 1
			guisliderext 15 numplayers 0 256 [] [] [] [0xC0C0C0] [] [0xFFFFFF]
		]
	] [guistatus_msg = "change the numplayers (range: 0-256)^n^fB/numplayers"]
	guisplit2 [guitext "Maxplayers:"] [
		guilist [
			guifield maxplayers 3 [] [0xFFFFFF] [] [] [] ""
			guistrut 1
			guilist [
				guistrut 0.12
				if (= $maxplayers (getvardef maxplayers 1)) [
					guinohitfx [
						guiimage "textures/checkdisable" [] 0.6
					]
				][
					guiimage "textures/guiexit" [maxplayers (getvardef maxplayers 1)] 0.6
				]
			]
			guistrut 1
			guisliderext 15 maxplayers 0 256 [] [] [] [0xC0C0C0] [] [0xFFFFFF]
		]
	] [guistatus_msg = "Maximum players who can play on this map (range: 0-256)^n^fB/maxplayers"]
	guisplit2 [guitext "Asymetric Map:"] [
		guilist [
			guifield mapbalance 3 [] [0xFFFFFF] [] [] [] ""
			guistrut 1
			guilist [
				guistrut 0.12
				if (= $mapbalance (getvardef mapbalance 1)) [
					guinohitfx [
						guiimage "textures/checkdisable" [] 0.6
					]
				][
					guiimage "textures/guiexit" [mapbalance (getvardef mapbalance 1)] 0.6
				]
			]
			guistrut 1
			guisliderext 4 mapbalance 0 3 [] [] [] [0xC0C0C0] [] [0xFFFFFF]
		]
	] [guistatus_msg = "Switch the teams after halftime^n^fo0 ^fw= No balance; ^fo1 ^fw= Only balance in ctf/dac/bb; ^fo2 ^fw= balance in all modes; 3 = forced^n^fB/mapbalance"]
	guispring 20 10
	guitext "Help"
]

mapedit_tab = [
	guistayopen [
		guilist [//first menu row
			guilist [
				guilist [
					bordertabbutton "Info" [sub1_mapedit_active = "info Info"] 1 "command" "sub1_mapedit_active"
					guistrut 0.5
					bordertabbutton "Save and load" [sub1_mapedit_active = "save_and_load Save_and_load"] 1 "command" "sub1_mapedit_active"
					guistrut 0.5
					bordertabbutton "Map settings" [sub1_mapedit_active = "map_settings Map_settings"] 1 "command" "sub1_mapedit_active"
				]
				guistrut 0.4
			]
			guistrut 0.6
		]
		((format "sub2_mapedit_%1" (sublist $sub1_mapedit_active 0 1)) ) //cexecutes the choosen menu; the first is the exec menu the second the name of the button
	]
	guistatus $guistatus_msg [1500]
]
//~~~~~~~~~~~~~~~~~~
sub2_material_set_material = [
	guibar 5 0 0xFFFFFF
	guistrut 0.5

	guitext "material"
]
sub2_material_options = [
	guibar 5 0 0xFFFFFF
	guistrut 0.5

	guitext "options"
]

material_tab = [
	guistayopen [
		guilist [//first menu row
			guilist [
				guilist [
					bordertabbutton "Set material" [sub1_material_active = "set_material Set_material"] 1 "command" "sub1_material_active"
					guistrut 0.5
					bordertabbutton "Options" [sub1_material_active = "options Options"] 1 "command" "sub1_material_active"
					guistrut 0.5
				]
				guistrut 0.4
			]
			guistrut 0.6
		]
		((format "sub2_material_%1" (sublist $sub1_material_active 0 1)) ) //cexecutes the choosen menu
	]
	guistatus $guistatus_msg [1500]
]

// gui structure
newgui editing_gui [
	guiheader "map"
		mapedit_tab
	guitab "Material"
		material_tab
		
	bordertabbuttonrollover_test //guirollover for bordertabs to make them red
]

// do
showgui editing_gui